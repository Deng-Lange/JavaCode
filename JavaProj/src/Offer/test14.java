package Offer;

public class test14 {
    //剪绳子 1
    //给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且 m>1）
    //每段绳子的长度记为 k[0],k[1]...k[m-1]
    //请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
    //例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是18
    /*
    推论：1、当所有绳段长度相等时，乘积最大 2、最优的绳段长度为 3
    切分规则：
    最优：把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况
    次优：若最后一段绳子长度为 2，则保留，不再拆为 1+1
    最差：若最后一段绳子长度为 1，则应把一份 3+1 替换为 2+2，因为 2×2 > 3×1
    算法流程：
    1、当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m>1 段，因此必须剪出一段长度为 1 的绳子，即返回 n−1
    2、当 n>3 时，求 n 除以 3 的整数部分 a 和余数部分 b （即 n=3a+b ），并分为以下三种情况：
       当 b=0 时，直接返回 3^a；
       当 b=1 时，要将一个 1+3 转换为 2+2，因此返回 (3^(a-1))×4；
       当 b=2 时，返回 (3^a)×2。
     Math.pow(x,y)方法：返回 x 的 y 次方
     */
    public int cuttingRope1(int n) {
        if(n <= 3){
            return n - 1;
        }
        int a = n / 3;
        int b = n % 3;
        if(b == 0){
            return (int)Math.pow(3, a);
        }
        if(b == 1){
            return (int)Math.pow(3, a - 1) * 4;
        }
        return (int)Math.pow(3, a) * 2;
    }
    //剪绳子 2
    //给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1）
    //每段绳子的长度记为 k[0],k[1]...k[m - 1]
    //请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？
    //例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是18
    /*
    大数求余解法：
    大数越界：当 a 增大时，最后返回的 3^a 大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。
    大数求余问题：在仅使用 int32 类型存储的前提下，正确计算 x^a 对 p 求余（即 x^a⊙p ）的值。
    解决方案： 循环求余、快速幂求余，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：
              (xy)⊙p=[(x⊙p)(y⊙p)]⊙p
     */
    //求 (x^a) % p —— 循环求余法（固定搭配建议背诵）
    //x为底数，a为幂，p为要取的模
    public long  remainder(int x,int a,int p){
        long rem = 1 ;
        for (int i = 0; i < a; i++) {
            rem = (rem * x) % p ;
        }
        return rem;
    }
    public int cuttingRope2(int n) {
        if(n <= 3){
            return n - 1;
        }
        int x = 3, a = n / 3, b = n % 3, p = 1000000007;
        long rem = 1;
        //直接套循环求余公式
        //b == 1代表余数为 1的时候，需要单独取出一个 3出来凑成 2*2达到最大值效果
        for(int i = 0; i < ((b == 1)?a-1:a); i++) {
            rem = (rem * x) % p;
        }
        if(b == 0) {
            return (int)(rem % p);
        }
        if(b == 1) {
            return (int)(rem * 4 % p);
        }
        return (int)(rem * 2 % p);
    }
}
